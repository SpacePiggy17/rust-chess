# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

A1: Square
A2: Square
A3: Square
A4: Square
A5: Square
A6: Square
A7: Square
A8: Square
B1: Square
B2: Square
B3: Square
B4: Square
B5: Square
B6: Square
B7: Square
B8: Square
BISHOP: PieceType
BLACK: Color
C1: Square
C2: Square
C3: Square
C4: Square
C5: Square
C6: Square
C7: Square
C8: Square
COLORS: builtins.list[Color]
D1: Square
D2: Square
D3: Square
D4: Square
D5: Square
D6: Square
D7: Square
D8: Square
E1: Square
E2: Square
E3: Square
E4: Square
E5: Square
E6: Square
E7: Square
E8: Square
F1: Square
F2: Square
F3: Square
F4: Square
F5: Square
F6: Square
F7: Square
F8: Square
G1: Square
G2: Square
G3: Square
G4: Square
G5: Square
G6: Square
G7: Square
G8: Square
H1: Square
H2: Square
H3: Square
H4: Square
H5: Square
H6: Square
H7: Square
H8: Square
KING: PieceType
KNIGHT: PieceType
PAWN: PieceType
PIECES: builtins.list[PieceType]
QUEEN: PieceType
ROOK: PieceType
WHITE: Color
class Bitboard:
    r"""
    Bitboard class.
    Represents a 64-bit unsigned integer.
    Each bit represents a square on the chessboard.
    The least-significant bit represents a1, and the most-significant bit represents h8.
    Supports bitwise operations and iteration.
    Also supports comparison and equality.
    """
    def __new__(cls, bitboard_or_square:typing.Any) -> Bitboard:
        r"""
        Create a new Bitboard from a 64-bit integer or a square
        """
    @staticmethod
    def from_square(square:Square) -> Bitboard:
        r"""
        Create a new Bitboard from a square
        """
    @staticmethod
    def from_uint(bitboard:builtins.int) -> Bitboard:
        r"""
        Create a new Bitboard from an unsigned 64-bit integer
        """
    def to_square(self) -> Square:
        r"""
        Convert the Bitboard to a square.
        This grabs the least-significant square.
        """
    def to_uint(self) -> builtins.int:
        r"""
        Convert the Bitboard to an unsigned 64-bit integer
        """
    def get_string(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the Bitboard to a string.
        Displays the bitboard in an 8x8 grid.
        a1 is the top-left corner, h8 is the bottom-right corner.
        To make a1 the bottom-left corner and h8 the top-right corner, call `flip_vertical()` on the bitboard.
        Very useful for debugging purposes.
        """
    def popcnt(self) -> builtins.int:
        r"""
        Count the number of squares in the Bitboard
        """
    def flip_vertical(self) -> Bitboard:
        r"""
        Flip a bitboard vertically.
        View it from the opponent's perspective.
        Useful for operations that rely on symmetry, like piece-square tables.
        """
    def __iter__(self) -> Bitboard:
        r"""
        Return an iterator of the bitboard
        """
    def __next__(self) -> typing.Optional[Square]:
        r"""
        Get the next square in the Bitboard.
        Removes the square from the Bitboard.
        """
    def __invert__(self) -> Bitboard:
        r"""
        Bitwise NOT operation
        """
    def __and__(self, other:typing.Any) -> Bitboard:
        r"""
        Bitwise AND operation (self & other).
        """
    def __rand__(self, other:typing.Any) -> Bitboard:
        r"""
        Reflected bitwise AND operation (other & self).
        """
    def __iand__(self, other:typing.Any) -> None:
        r"""
        In-place bitwise AND operation (self &= other).
        """
    def __or__(self, other:typing.Any) -> Bitboard:
        r"""
        Bitwise OR operation (self | other).
        """
    def __ror__(self, other:typing.Any) -> Bitboard:
        r"""
        Reflected bitwise OR operation (other | self).
        """
    def __ior__(self, other:typing.Any) -> None:
        r"""
        In-place bitwise OR operation (self |= other).
        """
    def __xor__(self, other:typing.Any) -> Bitboard:
        r"""
        Bitwise XOR operation (self ^ other).
        """
    def __rxor__(self, other:typing.Any) -> Bitboard:
        r"""
        Reflected bitwise XOR operation (other ^ self).
        """
    def __ixor__(self, other:typing.Any) -> None:
        r"""
        In-place bitwise XOR operation (self ^= other).
        """
    def __mul__(self, other:typing.Any) -> Bitboard:
        r"""
        Multiplication operation (self * other).
        """
    def __rmul__(self, other:typing.Any) -> Bitboard:
        r"""
        Reflected multiplication operation (other * self).
        """
    def __imul__(self, other:typing.Any) -> None:
        r"""
        In-place multiplication operation (self *= other).
        """
    def __lshift__(self, shift:builtins.int) -> Bitboard:
        r"""
        Left shift operation (self << shift).
        """
    def __rlshift__(self, _other:typing.Any) -> Bitboard:
        r"""
        Reflected left shift operation (not typically used)
        """
    def __ilshift__(self, shift:builtins.int) -> None:
        r"""
        In-place left shift operation (self <<= shift).
        """
    def __rshift__(self, shift:builtins.int) -> Bitboard:
        r"""
        Right shift operation (self >> shift).
        """
    def __rrshift__(self, _other:typing.Any) -> Bitboard:
        r"""
        Reflected right shift operation (not typically used)
        """
    def __irshift__(self, shift:builtins.int) -> None:
        r"""
        In-place right shift operation (self >>= shift).
        """

class Board:
    r"""
    Board class.
    Represents the state of a chess board.
    """
    halfmove_clock: builtins.int
    r"""
    Get the halfmove clock.
    
    ```python
    >>> rust_chess.Board().halfmove_clock
    0
    ```
    """
    fullmove_number: builtins.int
    r"""
    Get the fullmove number.
    
    ```python
    >>> rust_chess.Board().fullmove_number
    1
    ```
    """
    turn: Color
    r"""
    Get the current player to move.
    
    ```python
    >>> board = rust_chess.Board()
    >>> board.turn
    True
    >>> print(board.turn)
    WHITE
    ```
    """
    en_passant: typing.Optional[Square]
    r"""
    Get the en passant square, otherwise None.
    
    ```python
    >>> rust_chess.Board().en_passant
    
    >>> rust_chess.Board().en_passant == None
    True
    >>> rust_chess.Board("rnbqkbnr/pp2p1pp/2p5/3pPp2/5P2/8/PPPP2PP/RNBQKBNR w KQkq f6 0 4").en_passant
    f5
    ```
    """
    def __new__(cls, fen:typing.Optional[builtins.str]=None) -> Board:
        r"""
        Create a new board from a FEN string, otherwise default to the starting position.
        
        ```python
        >>> rust_chess.Board()
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        >>> rust_chess.Board("rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2")
        rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2
        ```
        """
    def get_fen(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> rust_chess.Board().get_fen()
        'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> print(rust_chess.Board())
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the FEN string representation of the board.
        
        ```python
        >>> print(rust_chess.Board())
        rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
        ```
        """
    @staticmethod
    def from_fen(fen:builtins.str) -> Board:
        r"""
        Create a new board from a FEN string.
        
        ```python
        >>> rust_chess.Board.from_fen("rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2")
        rnbqkbnr/ppp1pppp/8/3p4/2P1P3/8/PP1P1PPP/RNBQKBNR b KQkq - 0 2
        ```
        """
    def get_piece_type_on(self, square:Square) -> typing.Optional[PieceType]:
        r"""
        Get the piece type on a square, otherwise None.
        Different than `get_piece_on` because it returns the piece type, which does not include color.
        
        ```python
        >>> rust_chess.Board().get_piece_type_on(rust_chess.A1)
        R
        >>> rust_chess.Board().get_piece_type_on(rust_chess.E8)
        K
        ```
        """
    def get_color_on(self, square:Square) -> typing.Optional[Color]:
        r"""
        Get the color of the piece on a square, otherwise None.
        
        ```python
        >>> rust_chess.Board().get_color_on(rust_chess.A1)
        True
        >>> print(rust_chess.Board().get_color_on(rust_chess.A1))
        WHITE
        >>> rust_chess.Board().get_color_on(rust_chess.E8)
        False
        """
    def get_piece_on(self, square:Square) -> typing.Optional[Piece]:
        r"""
        Get the piece on a square (color-inclusive), otherwise None.
        Different than `get_piece_on` because it returns the piece, which includes color.
        
        ```python
        >>> rust_chess.Board().get_piece_on(rust_chess.A1)
        R
        >>> rust_chess.Board().get_piece_on(rust_chess.E8)
        k
        ```
        """
    def is_zeroing(self, chess_move:Move) -> builtins.bool:
        r"""
        Check if a move is a capture or a pawn move.
        Doesn't check legality.
        """
    def is_legal_move(self, chess_move:Move) -> builtins.bool:
        r"""
        Check if the move is legal (supposedly very slow according to the chess crate).
        Use this function for moves not generated by the move generator.
        `is_legal_quick` is faster for moves generated by the move generator.
        
        ```python
        >>> move = rust_chess.Move("e2e4")
        >>> rust_chess.Board().is_legal_move(move)
        True
        >>> move2 = rust_chess.Move("e2e5")
        >>> rust_chess.Board().is_legal_move(move2)
        False
        ```
        """
    def make_move_new(self, chess_move:Move, check_legality:builtins.bool=False) -> Board:
        r"""
        Make a move onto a new board
        """
    def make_move(self, chess_move:Move, check_legality:builtins.bool=False) -> None:
        r"""
        Make a move on the current board
        """
    def remove_move(self, chess_move:Move) -> None:
        r"""
        Remove a move from the move generator.
        Prevents the move from being generated.
        Useful if you already have a certain move and don't need to generate it again.
        """
    def reset_move_generator(self) -> None:
        r"""
        Reset the move generator for the current board
        """
    def next_move(self) -> typing.Optional[Move]:
        r"""
        Get the next remaining move of the generator.
        Updates the move generator to the next move.
        Unless the mask is set, this will return the next legal move by default.
        """
    def generate_legal_moves(self) -> MoveGenerator:
        r"""
        Generate the next remaining legal moves for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        """
    def generate_legal_captures(self) -> MoveGenerator:
        r"""
        Generate the next remaining legal captures for the current board.
        Exhausts the move generator if fully iterated over.
        Updates the move generator.
        """
    def is_insufficient_material(self) -> builtins.bool:
        r"""
        Checks if the side to move has insufficient material to checkmate the opponent.
        The cases where this is true are:
            1. K vs K
            2. K vs K + N
            3. K vs K + B
            4. K + B vs K + B with the bishops on the same color.
        """
    def is_fifty_moves(self) -> builtins.bool:
        r"""
        Checks if the halfmoves since the last pawn move or capture is >= 100
        and the game is ongoing (not checkmate or stalemate).
        
        ```python
        >>> rust_chess.Board().is_fifty_moves
        False
        >>> rust_chess.Board("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 50 1").is_fifty_moves()
        True
        ```
        """
    def is_seventy_five_moves(self) -> builtins.bool:
        r"""
        Checks if the halfmoves since the last pawn move or capture is >= 150
        and the game is ongoing (not checkmate or stalemate).
        """
    def is_fivefold_repetition(self) -> builtins.bool: ...
    def is_check(self) -> builtins.bool:
        r"""
        Checks if the side to move is in check.
        
        ```python
        >>> rust_chess.Board().is_check
        False
        >>> rust_chess.Board("rnb1kbnr/pppp1ppp/4p3/8/6Pq/5P2/PPPPP2P/RNBQKBNR w KQkq - 1 3").is_check()
        True
        ```
        """
    def is_stalemate(self) -> builtins.bool:
        r"""
        Checks if the side to move is in stalemate
        """
    def is_checkmate(self) -> builtins.bool:
        r"""
        Checks if the side to move is in checkmate
        """
    def get_status(self) -> BoardStatus:
        r"""
        Get the status of the board
        """

class Color:
    r"""
    Color enum class.
    White is True, Black is False.
    
    ```python
    >>> color = rust_chess.WHITE
    
    >>> color
    True
    >>> print(color)
    WHITE
    >>> color == rust_chess.BLACK
    False
    >>> color == (not rust_chess.BLACK)
    True
    ```
    """
    def get_string(self) -> builtins.str:
        r"""
        Get the color as a string.
        
        ```python
        >>> rust_chess.WHITE.get_string()
        'WHITE'
        >>> rust_chess.BLACK.get_string()
        'BLACK'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the color as a string.
        
        ```python
        >>> print(rust_chess.WHITE)
        WHITE
        >>> print(rust_chess.BLACK)
        BLACK
        ```
        """
    def __bool__(self) -> builtins.bool:
        r"""
        Get the color as a boolean.
        
        ```python
        >>> bool(rust_chess.WHITE)
        True
        >>> bool(rust_chess.BLACK)
        False
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the color as a boolean string.
        
        ```python
        >>> rust_chess.WHITE
        True
        >>> rust_chess.BLACK
        False
        ```
        """
    def __eq__(self, other:typing.Any) -> builtins.bool:
        r"""
        Compare the color to another color or boolean.
        
        ```python
        >>> rust_chess.WHITE == rust_chess.BLACK
        False
        >>> rust_chess.WHITE == True
        True
        ```
        """

class Move:
    r"""
    Move class.
    Represents a chess move.
    The move is represented as a source square, destination square, and optional promotion piece.
    
    ```python
    >>> move = rust_chess.Move(rust_chess.A4, rust_chess.B1)
    >>> move
    Move(a4, b1, None)
    >>> print(move)
    a4b1
    >>> rust_chess.Move("a2a1q")
    Move(a2, a1, QUEEN)
    >>> move.get_uci() == rust_chess.Move.from_uci("a4b1") // FIXME
    True
    >>> move.source
    a2
    >>> move.dest
    a4
    >>> move.promotion
    
    >>> move.promotion == None
    True
    ```
    """
    source: Square
    r"""
    Get the source square of the move.
    
    ```python
    >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
    >>> move.source
    a2
    ```
    """
    dest: Square
    r"""
    Get the destination square of the move.
    
    
    ```python
    >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
    >>> move.dest
    a4
    ```
    """
    promotion: typing.Optional[PieceType]
    r"""
    Get the promotion piece of the move, otherwise None.
    
    ```python
    >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
    >>> move.promotion
    
    >>> move.promotion == None
    True
    >>> move = rust_chess.Move("g2g1q")
    >>> move.promotion
    QUEEN
    ```
    """
    def __new__(cls, source_or_uci:typing.Any, dest:typing.Optional[Square]=None, promotion:typing.Optional[PieceType]=None) -> Move:
        r"""
        Create a new move from a source, destination, and optional promotion piece or UCI string.
        
        ```python
        >>> rust_chess.Move(rust_chess.A2, rust_chess.A4)
        (a2, a4, None)
        >>> rust_chess.Move("g2g1q")
        (g2, g1, QUEEN)
        ```
        """
    @staticmethod
    def from_uci(uci:builtins.str) -> Move:
        r"""
        Create a new move from a UCI string (e.g. "e2e4").
        
        ```python
        >>> rust_chess.Move.from_uci("e2e4")
        Move(e2, e4, None)
        ```
        """
    def get_uci(self) -> builtins.str:
        r"""
        Get the UCI string representation of the move (e.g. "e2e4").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move.get_uci()
        'a2a4'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the UCI string representation of the move (e.g. "e2e4").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> print(move)
        a2a4
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the internal representation of the move (e.g. "Move(e2, e4, None)").
        
        ```python
        >>> move = rust_chess.Move(rust_chess.A2, rust_chess.A4)
        >>> move
        Move(e2, e4, None)
        ```
        """

class MoveGenerator:
    r"""
    Move iterator class for generating legal moves.
    Not intended for direct use.
    Use the `Board` class methods for generating moves.
    """
    def __iter__(self) -> MoveGenerator:
        r"""
        Return an iterator of the generator
        """
    def __next__(self) -> typing.Optional[Move]:
        r"""
        Get the next move in the generator
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the type of the move generator
        """

class Piece:
    r"""
    Piece class.
    Represents a chess piece with a type and color.
    Uses the PieceType and Color classes.
    Supports comparison and equality.
    A white piece is considered less than a black piece of the same type.
    
    ```python
    TODO
    ```
    """
    piece_type: PieceType
    r"""
    Get the piece type of the piece
    """
    color: Color
    r"""
    Get the color of the piece
    """
    def __new__(cls, piece_type:PieceType, color:Color) -> Piece:
        r"""
        Create a new piece from a piece type and color
        """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the piece (0-5)
        """
    def get_string(self) -> builtins.str:
        r"""
        Convert the piece to a string
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the piece to a string
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the piece to a string
        """

class PieceType:
    r"""
    Piece type enum class.
    Represents the different types of chess pieces.
    Indexing starts at 0 (PAWN) and ends at 5 (KING).
    Supports comparison and equality.
    Does not include color.
    
    `rust_chess` has constants for each piece type (e.g. PAWN, KNIGHT, etc.).
    
    ```python
    >>> piece = rust_chess.PAWN
    
    >>> print(piece)
    P
    >>> piece == rust_chess.PAWN
    True
    >>> piece == rust_chess.KNIGHT
    False
    >>> piece.get_index()
    0
    >>> piece < rust_chess.KNIGHT
    True
    ```
    """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the piece.
        Ranges from 0 (PAWN) to 5 (KING).
        
        ```python
        >>> rust_chess.BISHOP.get_index()
        2
        ```
        """
    def get_string(self, color:Color=...) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> rust_chess.PAWN.get_string()
        P
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> print(rust_chess.PAWN)
        P
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Convert the piece to a string.
        Returns the capital piece type letter.
        
        ```python
        >>> rust_chess.PAWN
        P
        ```
        """

class Square:
    r"""
    Square class.
    Represents a square on the chessboard.
    The square is represented as an integer (0-63) or a string (e.g. "e4").
    Supports comparison and equality.
    
    `rust_chess` has constants for each square (e.g. A1, B2, etc.).
    
    ```python
    >>> square = rust_chess.Square(0)
    >>> square
    a1
    >>> print(square)
    a1
    >>> square == rust_chess.Square("a1")
    True
    >>> square == rust_chess.A1
    True
    >>> square.get_index()
    0
    >>> rust_chess.A4 == 24
    True
    >>> rust_chess.G4.get_rank()
    3
    >>> rust_chess.G4.get_file()
    6
    TODO
    ```
    """
    def __new__(cls, square:typing.Any) -> Square:
        r"""
        Creates a new square from an integer (0-63) or a string (e.g. "e4").
        
        ```python
        >>> rust_chess.Square(0)
        a1
        >>> rust_chess.Square("e4")
        e4
        ```
        """
    def get_index(self) -> builtins.int:
        r"""
        Get the index of the square (0-63).
        Indexing starts at 0 (a1) and ends at 63 (h8).
        
        ```python
        >>> rust_chess.Square("e4").get_index()
        28
        ```
        """
    def to_bitboard(self) -> Bitboard:
        r"""
        Convert a square to a bitboard
        """
    @staticmethod
    def from_index(index:builtins.int) -> Square:
        r"""
        Create a new square from an index.
        Indexing starts at 0 (a1) and ends at 63 (h8).
        
        ```python
        >>> rust_chess.Square.from_index(0)
        a1
        ```
        """
    @staticmethod
    def from_rank_file(rank:builtins.int, file:builtins.int) -> Square:
        r"""
        Create a new square from rank and file.
        Rank and file are 0-indexed (0-7).
        
        ```python
        >>> rust_chess.Square.from_rank_file(0, 3)
        d1
        ```
        """
    def get_name(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4").
        
        ```python
        >>> rust_chess.E4.get_name()
        'e4'
        ```
        """
    def __str__(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4"),
        
        ```python
        >>> print(rust_chess.E4)
        e4
        ```
        """
    def __repr__(self) -> builtins.str:
        r"""
        Get the name of the square (e.g. "e4").
        
        ```python
        >>> rust_chess.E4
        e4
        ```
        """
    def get_color(self) -> Color:
        r"""
        Get the color of the square on the chessboard
        """
    @staticmethod
    def from_name(square_name:builtins.str) -> Square:
        r"""
        Create a new square from a name (e.g. "e4").
        Not really needed since you can use the square constants.
        Could also just call the constructor with the name string.
        
        ```python
        >>> rust_chess.Square.from_name("d2")
        d2
        ```
        """
    def __richcmp__(self, other:typing.Any, op:int) -> builtins.bool:
        r"""
        Compare the square to another square or integer.
        
        ```python
        >>> rust_chess.Square("d2") == rust_chess.D2
        True
        >>> rust_chess.Square("d2") == 11
        True
        >>> rust_chess.G6 > rust_chess.D3
        True
        >>> rust_chess.G6 <= 56
        True
        ```
        """
    def get_rank(self) -> builtins.int:
        r"""
        Get the rank of the square as an integer (0-7).
        
        ```python
        >>> rust_chess.E4.get_rank()
        3
        ```
        """
    def get_file(self) -> builtins.int:
        r"""
        Get the file of the square as an integer (0-7).
        
        ```python
        >>> rust_chess.E4.get_file()
        4
        ```
        """
    def up(self) -> typing.Optional[Square]:
        r"""
        Returns the square above, otherwise None.
        
        ```python
        >>> rust_chess.H5.up()
        h6
        ```
        """
    def down(self) -> typing.Optional[Square]:
        r"""
        Returns the square below, otherwise None.
        
        ```python
        >>> rust_chess.H5.down()
        h4
        ```
        """
    def left(self) -> typing.Optional[Square]:
        r"""
        Returns the square to the left, otherwise None.
        
        ```python
        >>> rust_chess.H5.left()
        g5
        ```
        """
    def right(self) -> typing.Optional[Square]:
        r"""
        Returns the square to the right, otherwise None
        
        ```python
        >>> rust_chess.H5.right()
        
        >>> rust_chess.H5.right() == None
        True
        ```
        """

class BoardStatus(Enum):
    r"""
    Board status enum class.
    Represents the status of a chess board.
    The status can be one of the following:
        Ongoing, five-fold repetition, seventy-five moves, insufficient material, stalemate, or checkmate.
    Supports comparison and equality.
    """
    ONGOING = ...
    FIVE_FOLD_REPETITION = ...
    SEVENTY_FIVE_MOVES = ...
    INSUFFICIENT_MATERIAL = ...
    STALEMATE = ...
    CHECKMATE = ...

